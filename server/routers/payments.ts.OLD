import { z } from "zod";
import { publicProcedure, protectedProcedure, router } from "../_core/trpc";
import { getDb, getTenantId } from "../db";
import { photoSales, appointments, mediaItems, stockPhotos } from "../../drizzle/schema";
import { 
  createPhotoCheckoutSession, 
  createAppointmentCheckoutSession,
  generateDownloadToken 
} from "../stripe";
import { eq , and } from "drizzle-orm";
import { TRPCError } from "@trpc/server";

export const paymentsRouter = router({
  /**
   * Create checkout session for photo purchase
   */
  createPhotoCheckout: publicProcedure
    .input(
      z.object({
        photoId: z.number(),
        productType: z.enum(["digital", "framed"]).default("digital"),
        frameSize: z.string().optional(),
        frameType: z.string().optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      // Get photo details
      const photoResult = await db
        .select()
        .from(stockPhotos)
        .where(and(eq(stockPhotos.id, input.photoId), eq(stockPhotos.tenantId, getTenantId(ctx))))
        .limit(1);
      
      const photo = photoResult[0];

      if (!photo) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Foto não encontrada",
        });
      }

      // Check if photo has price
      if (!photo.price || photo.price === 0) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Esta foto não está disponível para venda",
        });
      }

      // Calculate total price with customizations
      let totalPrice = Math.round(photo.price * 100); // Base price in cents

      if (input.productType === "framed") {
        const { framePricing, frameTypes } = await import("../../drizzle/schema");
        
        // Add frame size price
        if (input.frameSize) {
          const sizeResult = await db
            .select()
            .from(framePricing)
            .where(and(eq(framePricing.size, input.frameSize), eq(framePricing.tenantId, getTenantId(ctx))))
            .limit(1);
          
          if (sizeResult[0]) {
            totalPrice += sizeResult[0].basePrice;
          }
        }

        // Add frame type price
        if (input.frameType) {
          const typeResult = await db
            .select()
            .from(frameTypes)
            .where(and(eq(frameTypes.type, input.frameType), eq(frameTypes.tenantId, getTenantId(ctx))))
            .limit(1);
          
          if (typeResult[0]) {
            totalPrice += typeResult[0].additionalPrice;
          }
        }
      }

      // Build product description
      let productDescription = input.productType === "digital" 
        ? "Foto Digital (Alta Resolução)"
        : `Quadro Emoldurado ${input.frameSize || ""} - Moldura ${input.frameType || ""}`;

      // Create Stripe checkout session
      const session = await createPhotoCheckoutSession({
        photoId: photo.id,
        photoTitle: photo.title || `Foto #${photo.id}`,
        photoDescription: productDescription,
        photoUrl: photo.thumbnailUrl || photo.originalUrl,
        amount: totalPrice,
        successUrl: `${process.env.VITE_APP_URL || "http://localhost:3000"}/pagamento/sucesso?session_id={CHECKOUT_SESSION_ID}`,
        cancelUrl: `${process.env.VITE_APP_URL || "http://localhost:3000"}/pagamento/cancelado`,
      });

      // Create pending photo sale record
      await db.insert(photoSales).values({
        photoId: photo.id,
        buyerEmail: "pending@checkout.com", // Will be updated by webhook
        buyerName: "Pending",
        amount: totalPrice,
        stripeSessionId: session.id,
        status: "pending",
        productType: input.productType,
        frameSize: input.frameSize,
        frameType: input.frameType,
      });

      return {
        checkoutUrl: session.url,
        sessionId: session.id,
      };
    }),

  /**
   * Create checkout session for appointment payment
   */
  createAppointmentCheckout: protectedProcedure
    .input(
      z.object({
        appointmentId: z.number(),
        amount: z.number(), // in BRL (will be converted to cents)
      })
    )
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      // Get appointment details
      const appointmentResult = await db
        .select()
        .from(appointments)
        .where(and(eq(appointments.id, input.appointmentId), eq(appointments.tenantId, getTenantId(ctx))))
        .limit(1);
      
      const appointment = appointmentResult[0];

      if (!appointment) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Agendamento não encontrado",
        });
      }

      // Only admin can create payment links
      if (ctx.user.role !== "admin") {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Apenas administradores podem enviar links de pagamento",
        });
      }

      // Create Stripe checkout session
      const session = await createAppointmentCheckoutSession({
        appointmentId: appointment.id,
        serviceName: `Serviço Fotográfico - ${appointment.clientName}`,
        amount: Math.round(input.amount * 100), // Convert to cents
        clientEmail: appointment.clientEmail,
        clientName: appointment.clientName,
        successUrl: `${process.env.VITE_APP_URL || "http://localhost:3000"}/pagamento/sucesso?session_id={CHECKOUT_SESSION_ID}`,
        cancelUrl: `${process.env.VITE_APP_URL || "http://localhost:3000"}/pagamento/cancelado`,
      });

      // Update appointment with payment info
      await db
        .update(appointments)
        .set({
          finalPrice: Math.round(input.amount * 100),
          stripeSessionId: session.id,
          paymentStatus: "awaiting_payment",
          status: "awaiting_payment",
        })
        .where(and(eq(appointments.id, input.appointmentId), eq(appointments.tenantId, getTenantId(ctx))));

      return {
        checkoutUrl: session.url,
        sessionId: session.id,
      };
    }),

  /**
   * Get photo sale by download token
   */
  getPhotoSaleByToken: publicProcedure
    .input(z.object({ token: z.string() }))
    .query(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      const saleResult = await db
        .select()
        .from(photoSales)
        .where(and(eq(photoSales.downloadToken, input.token), eq(photoSales.tenantId, getTenantId(ctx))))
        .limit(1);
      
      const sale = saleResult[0];

      if (!sale) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Link de download inválido ou expirado",
        });
      }

      // Check if token is expired
      if (sale.downloadExpiresAt && new Date() > sale.downloadExpiresAt) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Link de download expirado",
        });
      }

      // Get photo details
      const photoResult = await db
        .select()
        .from(mediaItems)
        .where(and(eq(mediaItems.id, sale.photoId), eq(mediaItems.tenantId, getTenantId(ctx))))
        .limit(1);
      
      const photo = photoResult[0];

      if (!photo) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Foto não encontrada",
        });
      }

      // Increment download count
      await db
        .update(photoSales)
        .set({
          downloadCount: (sale.downloadCount || 0) + 1,
        })
        .where(and(eq(photoSales.id, sale.id), eq(photoSales.tenantId, getTenantId(ctx))));

      return {
        sale,
        photo,
      };
    }),

  /**
   * Get all photo sales (admin only)
   */
  getAllPhotoSales: protectedProcedure.query(async ({ ctx }) => {
    if (ctx.user.role !== "admin") {
      throw new TRPCError({
        code: "FORBIDDEN",
        message: "Acesso negado",
      });
    }

    const db = await getDb();
    if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

    const sales = await db
      .select()
      .from(photoSales)
      .where(eq(photoSales.tenantId, getTenantId(ctx)))
      .orderBy((t) => t.createdAt);

    return sales;
  }),
});
